#include <stdio.h>
#include <string.h> 
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
#include <stdlib.h>
#include <signal.h>
#include <time.h>

float x_hat = 0.0; // Current estimated x position of the e.e., generated by the motor, without including error
float x_hat_new = 0.0; // New value of the estimated x position
float vel_x = 0.0; // Current velocity of the motor
float dt = 1.0/30.0; // Rate at which the motor computes a new position
int reset = 0; // Will be set to one when a RESET signal is received

// Variables needed for the log file
FILE * log_file;
time_t rawtime;
struct tm * timeinfo;
char * timestamp;

// Writes the current time in the log file
void write_timestamp ()
{
    time(&rawtime); timeinfo = localtime(&rawtime);
    timestamp = asctime(timeinfo); timestamp[strlen(timestamp)-1] = 0; 
    fprintf(log_file, "%s -- ", timestamp);
}

// Signal handler for the STOP signal
void sig_handler_stop(int signo)
{
    if (signo == SIGUSR1) {
		vel_x = 0.0; // Immediately set the current velocity to zero
		write_timestamp(); // Report in the log file
        fprintf(log_file, "%s\n", "Signal STOP received"); fflush(log_file);
    }
}

// Signal handler for the RESET signal
void sig_handler_reset(int signo)
{
    if (signo == SIGUSR2) {
		reset = 1; // Activate the reset flag
    }
	write_timestamp(); // Report in the log file
    fprintf(log_file, "%s\n", "Signal RESET received"); fflush(log_file);
}

int main(int argc, char const *argv[])
{	
	// Open the log file
    log_file = fopen("log/motor1.log", "w");
	if (log_file == NULL) {
        perror("Error while opening the log file");
        return 1;
    }

	// Associate the signal SIGUSR1 with the signal handler 'sig_handler_stop'
    if (signal(SIGUSR1, sig_handler_stop) == SIG_ERR)
        printf("Can't catch signal SIGUSR1\n");

    // Associate the signal SIGUSR2 with the signal handler 'sig_handler_reset'
    if (signal(SIGUSR2, sig_handler_reset) == SIG_ERR)
        printf("Can't catch signal SIGUSR2\n");

	// Get the file descriptor of the read side of pipe vx
	int read_fd_vx;
    sscanf(argv[1], "%d", &read_fd_vx);
    
	// Get the file descriptor of the write side of pipe xhat
	int write_fd_xhat;
    sscanf(argv[2], "%d", &write_fd_xhat);

	while(1)
	{
		// Continuously read pipe vx. If there are not any data available, the process keeps its execution, since the pipe is non-blocking
		char last_command_received[1];
		int n = read(read_fd_vx, last_command_received, strlen(last_command_received)+1);

		// If there's a new value available, decodify it and update the current velocity
		if (n > 0)
		{
			if (strcmp(last_command_received, "0") == 0) // Speed decrease
			{
				if (vel_x > -2.0) // The minimum value of vel_x is -2
				{
					vel_x = vel_x - 0.5;
                    write_timestamp(); // Report in the log file
                    fprintf(log_file, "%s\n", "Velocity decreased"); fflush(log_file);
				}	
			}
			else if (strcmp(last_command_received, "1") == 0) // Speed stop
			{
				vel_x = 0;
				write_timestamp(); // Report in the log file
                fprintf(log_file, "%s\n", "Velocity set to zero"); fflush(log_file);
			}
			else if (strcmp(last_command_received, "2") == 0) // Speed increase
			{
				if (vel_x < 2.0) // The maximum value of vel_x is 2
				{
					vel_x += 0.5;
					write_timestamp(); // Report in the log file
                    fprintf(log_file, "%s\n", "Velocity increased"); fflush(log_file);
				}
			}
		}

		// In reset mode, the motor will have a constant re-winding velocity of -0.5
		if (reset == 1) vel_x = -0.5;

		// Compute the new position
		x_hat_new = x_hat + vel_x * dt;

		if (x_hat_new < 0.0)
		{
			x_hat_new = 0.0; // The minimum x position is 0

			// If the motor was in reset mode, switch to normal mode and set the velocity to zero, since the origin has been reached
			if(reset == 1) {
				reset = 0;
				vel_x = 0.0;
				write_timestamp(); // Report in the log file
                fprintf(log_file, "%s\n", "Zero position reached. Back to normal mode"); fflush(log_file);
			}
		}

		else if (x_hat_new > 40.0) x_hat_new = 40.0; // The maximum x position is 40

		// Only if the new computed position has changed w.r.t. the previous one, send it to the world (via the pipe xhat)
		if (x_hat_new != x_hat) 
		{
			int m = write(write_fd_xhat, &x_hat_new, sizeof(x_hat_new));
			if (m == -1) {
				perror("motor1: write error");
				return 1;
			}
			// Report in the log file
            write_timestamp();
			fprintf(log_file, "%s", "New X estimated position: ");
			fprintf(log_file, "%f\n", x_hat_new); fflush(log_file);
		}

		x_hat = x_hat_new; // Update the value of the position
		sleep(dt); // The motor computes the new position at a rate of 30Hz
	}

	fclose(log_file);
	return 0;
}