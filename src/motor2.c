#include <stdio.h>
#include <string.h> 
#include <fcntl.h> 
#include <sys/stat.h> 
#include <sys/types.h> 
#include <unistd.h> 
#include <stdlib.h>
#include <signal.h>
#include <time.h>

float z_hat = 0.0; // Current estimated z position of the e.e., generated by the motor, without including error
float z_hat_new = 0.0; // New value of the estimated z position
float vel_z = 0.0; // Current velocity of the motor
float dt = 1.0/30.0; // Rate at which the motor computes a new position
int reset = 0; // Will be set to one when a RESET signal is received

// Variables needed for the log file
FILE * log_file;
time_t rawtime;
struct tm * timeinfo;
char * timestamp;

// Writes the current time in the log file
void write_timestamp ()
{
    time(&rawtime); timeinfo = localtime(&rawtime);
    timestamp = asctime(timeinfo); timestamp[strlen(timestamp)-1] = 0; 
    fprintf(log_file, "%s -- ", timestamp);
}

// Signal handler for the STOP signal
void sig_handler_stop(int signo)
{
    if (signo == SIGUSR1) {
		vel_z = 0.0; // Immediately set the current velocity to zero
		write_timestamp(); // Report in the log file
        fprintf(log_file, "%s\n", "Signal STOP received"); fflush(log_file);
    }
}

// Signal handler for the RESET signal
void sig_handler_reset(int signo)
{
    if (signo == SIGUSR2) {
		reset = 1; // Activate the reset flag
    }
	write_timestamp(); // Report in the log file
    fprintf(log_file, "%s\n", "Signal RESET received"); fflush(log_file);
}

int main(int argc, char const *argv[])
{
	// Open the log file
    log_file = fopen("log/motor2.log", "w");
	if (log_file == NULL) {
        perror("Error while opening the log file");
        return 1;
    }

	// Associate the signal SIGUSR1 with the signal handler 'sig_handler_stop'
    if (signal(SIGUSR1, sig_handler_stop) == SIG_ERR)
        printf("Can't catch signal SIGUSR1\n");

	// Associate the signal SIGUSR2 with the signal handler 'sig_handler_reset'
    if (signal(SIGUSR2, sig_handler_reset) == SIG_ERR)
        printf("Can't catch signal SIGUSR2\n");

	// Get the file descriptor of the read side of pipe vz
	int read_fd_vz;
    sscanf(argv[1], "%d", &read_fd_vz);
    
	// Get the file descriptor of the write side of pipe zhat
	int write_fd_zhat;
    sscanf(argv[2], "%d", &write_fd_zhat);

	while(1)
	{
		// Continuously read pipe vz. If there are not any data available, the process keeps its execution, since the pipe is non-blocking
		char last_command_received[1];
		int n = read(read_fd_vz, last_command_received, strlen(last_command_received)+1);

		// If there's a new value available, decodify it and update the current velocity
		if (n > 0) {
			if (strcmp(last_command_received, "0") == 0) // Speed decrease
			{
				if (vel_z > -2.0) // The minimum value of vel_z is -2
				{
					vel_z = vel_z - 0.5;
					write_timestamp(); // Report in the log file
                    fprintf(log_file, "%s\n", "Velocity decreased"); fflush(log_file);
				}
			}
			else if (strcmp(last_command_received, "1") == 0) // Speed stop
			{
				vel_z = 0;
				write_timestamp(); // Report in the log file
                fprintf(log_file, "%s\n", "Velocity set to zero"); fflush(log_file);
			}

			else if (strcmp(last_command_received, "2") == 0) // Speed increase
			{
				if (vel_z < 2.0) // The maximum value of vel_x is 2
				{
					vel_z += 0.5;
					write_timestamp(); // Report in the log file
                    fprintf(log_file, "%s\n", "Velocity increased"); fflush(log_file);
				}
			}
		}

		// In reset mode, the motor will have a constant re-winding velocity of -0.5
		if (reset == 1) vel_z = -0.5;

		// Compute the new position
		z_hat_new = z_hat + vel_z * dt;

		if (z_hat_new < 0.0)
		{
			z_hat_new = 0.0; // The minimum z position is 0

			if(reset == 1) {
				reset = 0;
				vel_z = 0.0;
				write_timestamp(); // Report in the log file
                fprintf(log_file, "%s\n", "Zero position reached. Back to normal mode"); fflush(log_file);
			}
		}

		else if (z_hat_new > 10) z_hat_new = 10; // The maximum z position is 10

		// Only if the new computed position has changed w.r.t. the previous one, send it to the world (via the pipe zhat)
		if (z_hat_new != z_hat) 
		{
			int m = write(write_fd_zhat, &z_hat_new, sizeof(z_hat_new));
			if (m == -1) {
				perror("motor2: write error");
				return 1;
			}
			// Report in the log file
            write_timestamp();
			fprintf(log_file, "%s", "New Z estimated position: ");
			fprintf(log_file, "%f\n", z_hat_new); fflush(log_file);
		}

		z_hat = z_hat_new; // Update the value of the position
		sleep(dt); // The motor computes the new position at a rate of 30Hz
	}	

	fclose(log_file);
	return 0;
}
